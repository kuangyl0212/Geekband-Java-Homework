# 题目 01- 请你说一说 MySQL 的锁机制
要求：

* 按照锁的粒度，锁的功能来分析
  * 按锁粒度有：全局锁、表级锁、行级锁，全局锁锁的是整个库，表级锁是锁定某个表，行级锁是锁定某行或多行的索引，也可以锁定行锁引之间的间隙
  * 按功能分有共享锁和排它锁
  * 全局锁的锁定和解锁
    ```SQL
    flush tables with read lock;
    unlock tables;
    ```
  * 表级锁有：表读锁、表写锁、元数据锁、自增锁
    ```SQL
    lock table t read; # 加读锁
    lock table t write; # 加写锁
    ```
    加表读锁的session不能查询其他没有加表锁的表，对加读锁的表进行更新会提示错误；其他session可以查询家读锁的表，对其他会话加读锁的表更新会阻塞
    加表写锁的session对这个表可以查询和修改；其他session查询这个表会阻塞
  * 表级锁另一种是元数据锁：对表数据进行增删改查时加元数据读锁，对表结构进行修改时加元数据写锁
  * 自增锁：向包含AUTO_INCREMENT列的表中插入数据时会加自增锁

  * 行级锁是通过锁定索引树上的索引项来实现的；行级锁有：记录锁、间隙锁、临键锁以及插入意向锁；行锁也分读锁和写锁
  * 记录锁
    ```SQL
    select * from t where id = 1 lock in share mode; # 对id=1的记录加读锁
    select * from t where id = 1 lock for update; # 写锁
    ``` 
  * 间隙锁：锁的是索引区间，保证间隙内不能插入数据，可以解决当前读的幻读问题
  * 临键锁 = 间隙锁+记录锁的左开右闭区间
  * 插入意向锁：本质是一种特殊的间隙锁，多个意向锁之间只要插入的记录本身不冲突的话就不需要相互等待
* 什么是死锁，为什么会发生，如何排查？
* 行锁是通过加在什么上完成的锁定？
* 详细说说这条 SQL 的锁定情况： delete from tt where uid = 666 ;